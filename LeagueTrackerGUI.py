from QtGUI import Ui_MainWindow
from Client import Client
from flowlayout import FlowLayout
from PyQt5 import QtWidgets, QtCore, QtGui
from datetime import datetime
from PyQt5 import QtTest

def create_new_icon_widget(name, api_call_path, client, width=160, height=200, parent=None):
    """
    Creates a new simple widget containing an image and a small piece of text. Currently used mainly for champions,
    skins, and other purchasable items.

    :param name: Name of purchasable item. Manifests as the text in the widget.
    :type name: str
    :param api_call_path: Url to call to receive the appropriate image data.
    :type api_call_path: str
    :param client: Object representing program backend.
    :type client: Client
    :param width: Widget width in pixels. Default: 160.
    :param height: Widget height in pixels. Default: 200.
    :param parent: Qt object containing the returned widget.
    :return: A QWidget containing an image and some text.
    """
    # Creates and sets up the main widget
    icon_frame = QtWidgets.QFrame(parent=parent)
    icon_frame.setObjectName("icon_frame")
    icon_frame.setCursor(QtGui.QCursor(QtCore.Qt.OpenHandCursor))  # Indicates that the widget is clickable
    icon_frame.setFrameShape(QtWidgets.QFrame.Box)
    icon_frame.setMinimumSize(width, height)
    icon_frame.setMaximumSize(width, height)
    
    # Creates layout for the main widget
    icon_frame_qvboxlayout = QtWidgets.QVBoxLayout(icon_frame)
    icon_frame_qvboxlayout.setObjectName("icon_frame_qvboxlayout")
    
    # Creates and sets up the label to contain the widget's image
    image_label = QtWidgets.QLabel(icon_frame)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(1)  # Makes the image as large as possible
    sizePolicy.setHeightForWidth(image_label.sizePolicy().hasHeightForWidth())
    image_label.setSizePolicy(sizePolicy)
    
    # Loads the image data from the api, adds it to the label, and adds the label to the main widget
    image = QtGui.QImage()
    image.loadFromData(client.call_api_image(api_call_path).content)  # load image data from api
    image_pixmap = QtGui.QPixmap()
    image_pixmap = image_pixmap.fromImage(image).scaled(width - 20, height - 20 - (height - width))  # set image size
    image_label.setPixmap(image_pixmap)
    image_label.setAlignment(QtCore.Qt.AlignCenter)
    image_label.setObjectName("image_label")
    icon_frame_qvboxlayout.addWidget(image_label)
    
    # Creates and sets up the label to contain the widget's text, and adds it to the main widget
    name_label = QtWidgets.QLabel(icon_frame)
    # Make the text label small
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(name_label.sizePolicy().hasHeightForWidth())
    name_label.setSizePolicy(sizePolicy)
    name_label.setAlignment(QtCore.Qt.AlignCenter)
    name_label.setObjectName("name_label")
    name_label.setWordWrap(True)
    name_label.setText(name_label.fontMetrics().elidedText(name, QtCore.Qt.ElideRight, 100))  # TODO make this line work
    name_label.setToolTip(name)  # Hover text is the full text
    icon_frame_qvboxlayout.addWidget(name_label)
    
    # Boilerplate code generated by pyuic5
    _translate = QtCore.QCoreApplication.translate
    icon_frame.setWindowTitle(_translate("icon_frame", "Frame"))
    image_label.setText(_translate("icon_frame", ""))
    name_label.setText(_translate("icon_frame", name))
    QtCore.QMetaObject.connectSlotsByName(icon_frame)
    
    return icon_frame


def create_client_refresh_messageBox(firstOpen, parent=None):
    """
    Creates a QMessageBox popup window allowing the user to either close the program or try to find the client process.
    
    :param parent: Qt object containing the message box.
    :return: A QMessageBox window object with a message and 'Retry' and 'Close' buttons.
    """

    if firstOpen:
        text = "League of Legends client is not running. Check again?"
    else:
        text = "League of Legends has been quit. Please reopen and check again."
    client_refresh_messageBox = QtWidgets.QMessageBox(parent)
    client_refresh_messageBox.setIcon(QtWidgets.QMessageBox.Warning)
    client_refresh_messageBox.setText(text)
    client_refresh_messageBox.setWindowTitle("Client Not Running")
    client_refresh_messageBox.setStandardButtons(QtWidgets.QMessageBox.Retry | QtWidgets.QMessageBox.Close)
    client_refresh_messageBox.setDefaultButton(QtWidgets.QMessageBox.Retry)
    client_refresh_messageBox.setEscapeButton(QtWidgets.QMessageBox.Close)
    client_refresh_messageBox.buttonClicked.connect(client_refresh_button_clicked)
    return client_refresh_messageBox


def client_refresh_button_clicked(i):
    """
    Defines the action to be taken when the user clicks a button in the client refresh message box window.
    
    :param i: Contains information about the button pressed.
    """
    if i.text() == "Close":
        sys.exit()


class TrackerWindow(QtWidgets.QMainWindow):
    
    def __init__(self, *args, **kwargs):
        """
        Initialises the main window for the application. Inherits from QMainWindow.

        :param args: Non-Keyword Arguments
        :param kwargs: Keyword Arguments
        """
        super().__init__(*args, **kwargs)
        
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        
        self.setup_refresh_label_timer()
        self.setup_refresh_button()
        self.setup_champs_tab_layout()
        self.setup_current_event_tab_layout()
        
        self.last_refresh_time = None
        
        self.client = Client()
        while not self.client.clientRunning:
            create_client_refresh_messageBox(True, self.ui.centralwidget).exec_()
            self.client.check_client_running()
        self.refresh()
        
        self.populate_current_event_tab()

    def populate_current_event_tab(self):
        """Adds all purchasable item widgets to the current event tab."""
        event_shop = self.client.get_event_shop()
        for item in event_shop:
            self.ui.current_event_tab_scroll_area_widget_contents_layout.addWidget(
                create_new_icon_widget(
                    item[0], item[1], self.client, parent=self.ui.current_event_tab_scroll_area_widget_contents))
    
    def setup_champs_tab_layout(self):
        """Creates flow layout for the champs tab."""
        self.ui.champs_tab_scroll_area_widget_contents_layout = FlowLayout(
            self.ui.champs_tab_scroll_area_widget_contents)
        self.ui.champs_tab_scroll_area_widget_contents_layout.setObjectName(
            "champs_tab_scroll_area_widget_contents_layout")
    
    def setup_current_event_tab_layout(self):
        """Creates flow layout for the current event tab."""
        self.ui.current_event_tab_scroll_area_widget_contents_layout = FlowLayout(
            self.ui.current_event_tab_scroll_area_widget_contents)
        self.ui.current_event_tab_scroll_area_widget_contents_layout.setObjectName(
            "current_event_tab_scroll_area_widget_contents_layout")
    
    def setup_refresh_button(self):
        """Configures the refresh button."""
        self.ui.refresh_button.clicked.connect(self.refresh)
    
    def setup_refresh_label_timer(self):
        """Configures and starts the refresh label timer."""
        self.ui.refresh_label_timer = QtCore.QTimer(self.ui.last_refresh_label)
        self.ui.refresh_label_timer.setObjectName("refresh_label_timer")
        self.ui.refresh_label_timer.setInterval(30000)  # 60 seconds
        self.ui.refresh_label_timer.setSingleShot(False)  # repeat timer on timeout
        self.ui.refresh_label_timer.timeout.connect(self.reset_refresh_label)  # call reset_refresh_label on timeout
        self.ui.refresh_label_timer.start()
    
    def refresh(self):
        """Updates client data and resets its text."""
        try:
            self.client.update()
        except TypeError:
            # The client has been closed
            closing = True
            self.client.clientRunning = False
            self.client.lockfileFound = False

            # While the client is still closing, look for the lockfile
            while closing:
                # Wait one second before trying to open the file again
                QtTest.QTest.qWait(1000)
                try:
                    with open(self.client.currentDirectory, 'r'):
                        pass
                # Lockfile is gone, client is fully closed
                except FileNotFoundError:
                    closing = False
                    print("Client fully closed")

            # While the client is not running, ask if they user wants to refresh
            while not self.client.clientRunning:
                create_client_refresh_messageBox(False, self.ui.centralwidget).exec_()
                self.client.check_client_running()
            # Client is now running and can be refreshed
            self.refresh()

        self.ui.num_champs_owned_value_label.setText(self.client.get_num_champs(True))
        self.ui.max_blue_essence_needed_value_label.setText(self.client.get_ip_needed("max", True, True))
        
        self.last_refresh_time = datetime.now()
        self.reset_refresh_label()
    
    def reset_refresh_label(self):
        """Updates the refresh label with correct elapsed time."""
        elapsed_time = datetime.now() - self.last_refresh_time
        elapsed_seconds = elapsed_time.total_seconds()
        elapsed_minutes = int(elapsed_seconds / 60)
        
        if elapsed_minutes < 1:
            self.ui.last_refresh_label.setText("Last Refresh: < 1 minute ago")
        elif elapsed_minutes == 1:
            self.ui.last_refresh_label.setText("Last Refresh: 1 minute ago")
        elif elapsed_minutes > 60:
            self.ui.last_refresh_label.setText("Last Refresh: > 1 hour ago")
        else:
            self.ui.last_refresh_label.setText(f"Last Refresh: {elapsed_minutes} minutes ago")


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    window = TrackerWindow()
    window.show()
    sys.exit(app.exec_())
